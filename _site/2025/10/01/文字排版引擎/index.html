<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Hello-World">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>从0到1自定义文字排版引擎：原理篇 - 袁平 | HusterYP-Blog</title>

    <link rel="canonical" href="http://localhost:4000/2025/10/01/%E6%96%87%E5%AD%97%E6%8E%92%E7%89%88%E5%BC%95%E6%93%8E/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">非专业程序员</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    <li>
                        <a href="/tags/">Tags</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/tag-bg.jpg" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/tag-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#跨端渲染" title="跨端渲染">跨端渲染</a>
                        
                        <a class="tag" href="/tags/#Font" title="Font">Font</a>
                        
                    </div>
                    <h1>从0到1自定义文字排版引擎：原理篇</h1>
                    
                    
                    <h2 class="subheading">排版引擎原理、自定义排版引擎</h2>
                    
                    <span class="meta">Posted by 袁平 on October 1, 2025</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				<h1 id="引言">引言</h1>

<blockquote>
  <p>前面我们讲解了<a href="https://mp.weixin.qq.com/s/EYPO3sSjtIstD3RmlRCs9w">字符与编码</a>，知道了Character与Unicode的关系和区别，也介绍了<a href="https://mp.weixin.qq.com/s/96YJGYKLoxENC4qT9tYNoQ">字符（Character）、字形（Glyph）、字体的区别</a>，并通过实际解析一个Font文件，真正了解到了<a href="https://mp.weixin.qq.com/s/D0A8HAQaQNart7KAdWXyJg">Font文件中有什么</a>；如果你对这些概念还熟悉，推荐先阅读前面几篇文章打好基础。</p>
</blockquote>

<p>作为程序员，日常和文本打交道肯定最多，不知道你是否深入想过这样一个问题：</p>

<p>一段中英日等多国混排的文字，系统（排版引擎）是如何知道怎么排布每个文字的，特别是不同国家的语言排版规则不同，比如中文、英文是从左向右排列，阿拉伯文是从右向左排列的；阿拉伯文会有连字（ligature），中文没有连字；更细节的，为了增强文本的可读性和美观性，系统一般还会将文字紧凑处理（kerning）、连字处理（ligature）等，排版引擎在其中到底做了哪些事情，每一步的基本原理又是怎么样的，本文将带你逐步揭开排版引擎的神秘面纱。</p>

<p>通过本文，或许你也能自定义一个文字排版引擎了。</p>

<h1 id="一文本预处理unicode归一化">一、文本预处理/Unicode归一化</h1>

<p>在<a href="https://mp.weixin.qq.com/s/EYPO3sSjtIstD3RmlRCs9w">字符与编码</a>一文中，我们知道同一个字符可能对应多个code point，比如<code class="highlighter-rouge">👨‍👩‍👧</code>对应<code class="highlighter-rouge">U+1F468 + U+200D + U+1F469 + U+200D + U+1F467</code> ；甚至Unicode为了兼容历史编码，也允许一个字符有多种表示方法，比如<code class="highlighter-rouge">é</code>可以表示为：单一code point（U+00E9），组合code point（<code class="highlighter-rouge">U+0065 + U+0301</code>）。</p>

<p>预处理就是保证字符串在进行排版/字形选择（shaping）之前是稳定、唯一、可预测的，避免因为 Unicode 的多种表示方法导致排版不一致，比如避免<code class="highlighter-rouge">é</code>被分开成<code class="highlighter-rouge">e</code>和 <code class="highlighter-rouge">́</code>排版渲染。</p>

<p>预处理一般步骤是：</p>

<ul>
  <li><strong>编码转换</strong>：将字符统一成UTF-32编码</li>
  <li><strong>规范化（Normalization）</strong>：NFC/NFD/NFKC/NFKD等，Web 标准和绝大多数现代系统都默认使用NFC</li>
</ul>

<p><strong>Q：NFC/NFD/NFKC/NFKD是什么</strong></p>

<p>这些是Unicode标准里定义的几种规范化形式，区别是：</p>

<p><img src="/img/post/文字排版引擎/归一化标准.png" alt="归一化标准" /></p>

<h1 id="二分段">二、分段</h1>

<blockquote>
  <p>为什么要分段：不同国家、语言的排版规则不同，比如阿拉伯文有连字、中文没有，阿拉伯文从右到左排，中文从左往右排，分段之后方便后续的字体选择和shaping，比如HarfBuzz 这样的 shaping 引擎一次只能处理一个 Script run</p>
</blockquote>

<p>分段就是把字符串按 Unicode Script (Latin, Han, Hiragana, Katakana 等) 划分成 run（分组）。</p>

<p>原理比较简单，Unicode 为每个 code point 定义了一个 Script 属性，遍历字符串，按 Script 属性连续分段即可。</p>

<p>比如对于<code class="highlighter-rouge">Hello世界あい</code>，从左往右扫描字符串，每遇到 Script 改变，就切分出一个 run，最后会被划分成：</p>

<ul>
  <li><code class="highlighter-rouge">Hello</code>” → Latin</li>
  <li><code class="highlighter-rouge">世界</code> → Han</li>
  <li><code class="highlighter-rouge">あい</code> → Hiragana</li>
</ul>

<p><strong>特殊情况：</strong></p>

<p>有些字符的 Script = Common（标点、数字、空格）或 Inherited（音调符号、声调标记），这些字符分段时需要特殊处理，规则一般是：</p>

<ul>
  <li>如果是 Common → 继承相邻 run 的 Script（如果左右run都有Script，一般跟随左边；如果左边没有run，比如开头就是空格，那就跟随右边；如果左右都没有run，比如<code class="highlighter-rouge">!!!</code>，那整体就是一个Common run）。</li>
  <li>如果是 Inherited → 附着到前一个 base 字符的 Script。</li>
</ul>

<p>比如：</p>

<p><code class="highlighter-rouge">世界!</code> → “世界” (Han) + “!” (也归 Han run)</p>

<p><code class="highlighter-rouge">é</code> (e + 重音符) → 整体算 Latin</p>

<h1 id="三双向文本处理bidi">三、双向文本处理（BiDi）</h1>

<p>BiDi就是将字符从<strong>逻辑顺序</strong>处理成<strong>视觉顺序</strong>，计算机里字符串总是按逻辑顺序存储（用户输入顺序），但在渲染时，不同语言有不同的书写方向，比如中文、英文从左往右排列，阿拉伯文、希伯来文从右往左排列，如果一段文本中既有中文、英文，又有阿拉伯文、希伯来文，那还得处理混排时的顺序，BiDi就是处理混排情况下文本的实际显示顺序的。</p>

<p>在后续的例子中，为了方便演示，我们假设以小写字母作为LTR，以大写字母作为RTL，比如：</p>

<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">abc</span> <span class="nt">ABC</span>
<span class="nt">abc</span><span class="err">：表示</span><span class="nt">LTR</span><span class="err">（从左往右排）书写方向</span>
<span class="nt">ABC</span><span class="err">：表示</span><span class="nt">RTL</span><span class="err">（从右往左排）书写方向</span>
</code></pre></div></div>

<p>Unicode有一套完整的BiDi算法（细节可<a href="https://www.unicode.org/reports/tr9/">参考链接</a>），在介绍原理之前需要先了解几个基本概念：</p>

<p><strong>1）字符类型（Character Types）</strong></p>

<p>Unicode给每个code point定义了一个Bidi_Class的属性（Unicode的方向属性）：</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">L</code> = Left-to-Right（中文、英文…）</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">R</code> = Right-to-Left（希伯来文）</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">AL</code> = Arabic Letter（阿拉伯文）</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">EN</code> = European Number（欧洲数字）</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">AN</code> = Arabic Number（阿拉伯数字）</p>
  </li>
  <li><code class="highlighter-rouge">ON</code> = Other Neutral（标点符号）</li>
  <li>…</li>
</ul>

<p>这些方向属性会有一个隐含的分类：</p>

<ul>
  <li><strong>强类型</strong>：这类字符具有明确的方向性，如英文字母是从左往右（LTR），阿拉伯文是从右往左（RLT）</li>
  <li><strong>弱类型</strong>：这类字符方向性不明确，比如数字和一些符号（如出现在数字之间的符号<code class="highlighter-rouge">.</code>、 <code class="highlighter-rouge">,</code>等），比如阿拉伯数字<code class="highlighter-rouge">123</code>，</li>
  <li><strong>中性类型</strong>：这类字符完全没有方向性，如空格、标点符号（<code class="highlighter-rouge">.</code>、 <code class="highlighter-rouge">,</code>、 <code class="highlighter-rouge">?</code>等），它们的方向完全由周围的强类型字符决定</li>
</ul>

<p><img src="/img/post/文字排版引擎/BiDi_Class.png" alt="BiDi_Class" /></p>

<p>比如：</p>

<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 如下为计算机中存储的逻辑顺序</span>
<span class="nt">abc</span> <span class="nt">ABC</span>

<span class="nt">a</span><span class="o">(</span><span class="nt">L</span><span class="o">)</span> <span class="nt">b</span><span class="o">(</span><span class="nt">L</span><span class="o">)</span> <span class="nt">c</span><span class="o">(</span><span class="nt">L</span><span class="o">)</span> <span class="nt">space</span><span class="o">(</span><span class="nt">WS</span><span class="o">)</span> <span class="nt">A</span><span class="o">(</span><span class="nt">R</span><span class="o">)</span> <span class="nt">B</span><span class="o">(</span><span class="nt">R</span><span class="o">)</span> <span class="nt">C</span><span class="o">(</span><span class="nt">R</span><span class="o">)</span>
</code></pre></div></div>

<p><strong>2）段落基本方向（Base Direction）</strong></p>

<p>在没有明确指定段落方向时，会采用默认规则来确定段落基本方向，即选择段落中<strong>第一个强类型字符</strong>的方向作为段落基本方向，段落开头的弱/中性字符会被忽略，直到遇到第一个强类型字符；如果整段都没有强类型字符，则默认LTR。</p>

<p>比如：</p>

<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 如下为计算机中存储的逻辑顺序</span>
<span class="c1">// case-1</span>
<span class="nt">abc</span> <span class="nt">ABC</span>

<span class="nt">a</span><span class="o">(</span><span class="nt">L</span><span class="o">)</span> <span class="nt">b</span><span class="o">(</span><span class="nt">L</span><span class="o">)</span> <span class="nt">c</span><span class="o">(</span><span class="nt">L</span><span class="o">)</span> <span class="nt">space</span><span class="o">(</span><span class="nt">WS</span><span class="o">)</span> <span class="nt">A</span><span class="o">(</span><span class="nt">R</span><span class="o">)</span> <span class="nt">A</span><span class="o">(</span><span class="nt">R</span><span class="o">)</span> <span class="nt">C</span><span class="o">(</span><span class="nt">R</span><span class="o">)</span>

<span class="err">段落方向为</span><span class="nt">LTR</span>

<span class="o">//</span> <span class="nt">case-2</span>
<span class="s2">"123abc"</span>

<span class="nt">1</span><span class="o">(</span><span class="nt">EN</span><span class="o">)</span><span class="nt">2</span><span class="o">(</span><span class="nt">EN</span><span class="o">)</span><span class="nt">3</span><span class="o">(</span><span class="nt">EN</span><span class="o">)</span><span class="nt">a</span><span class="o">(</span><span class="nt">L</span><span class="o">)</span> <span class="nt">b</span><span class="o">(</span><span class="nt">L</span><span class="o">)</span> <span class="nt">c</span><span class="o">(</span><span class="nt">L</span><span class="o">)</span>

<span class="err">段落方向为</span><span class="nt">LTR</span>

<span class="o">//</span> <span class="nt">case-3</span>
<span class="s2">"123"</span>

<span class="nt">1</span><span class="o">(</span><span class="nt">EN</span><span class="o">)</span><span class="nt">2</span><span class="o">(</span><span class="nt">EN</span><span class="o">)</span><span class="nt">3</span><span class="o">(</span><span class="nt">EN</span><span class="o">)</span>

<span class="err">段落方向为默认</span><span class="nt">LTR</span>
</code></pre></div></div>

<p>段落基本方向主要有三个作用：</p>

<ul>
  <li>确定初始的嵌套等级（见下），如果基本方向为LTR，则嵌套等级从0开始；如果基本方向为RTL，则嵌套等级从1开始</li>
  <li>决定中性字符的方向，如果中性字符左右都没有强类型字符，那就会跟随段落方向，比如<code class="highlighter-rouge">Hello !</code>中<code class="highlighter-rouge">!</code>会跟随段落方向LTR</li>
  <li>决定段落中文档流方向，如果基本方向为LTR，文本将从容器左侧开始向右排；如果基本方向为RTL，文本将从容器右侧开始向左排</li>
</ul>

<p><strong>3）嵌套等级（Embedding Levels）</strong></p>

<p>BiDi算法中用偶数等级（0, 2, 4…）代表LTR方向，奇数等级（1, 3, 5…）代表RTL方向；如前所述，段落基本方向决定了初始的嵌套等级（0级为LTR，1级为RTL），当文本中出现方向变化时，算法会相应地提升嵌套等级。</p>

<p>从段落初始等级开始，当遇到方向变化时，就提升一个等级；对于强类型字符等级比较容易确定，对于弱类型与中性类型字符则需要结合上下文来共同确定。</p>

<p>对于弱类型字符：比如AN/EN数字及其之间的标点符号，这些字符即使在 RTL 文本中也通常按 LTR 书写。</p>

<p>对于中性字符：假设中性字符<code class="highlighter-rouge">c</code>左右字符（逻辑顺序）分别为<code class="highlighter-rouge">b</code>、<code class="highlighter-rouge">d</code>，</p>

<ul>
  <li>
    <p>如果b、d都为强类型字符，且<code class="highlighter-rouge">direction(b) = direction(d) = D</code>，则<code class="highlighter-rouge">direction(c) = D</code></p>
  </li>
  <li>如果b是强类型字符，且<code class="highlighter-rouge">direction(b) = RTL</code>，且d是AN或EN，则<code class="highlighter-rouge">direction(c) = RTL</code></li>
  <li>如果b是AN或EN，且d是强类型字符，且<code class="highlighter-rouge">direction(d) = RTL</code>，则<code class="highlighter-rouge">direction(c) = RTL</code></li>
  <li>如果b是AN或EN，且d是AN或EN，则<code class="highlighter-rouge">direction(c) = RTL</code></li>
  <li>否则<code class="highlighter-rouge">direction(c) = direction(EL(c))</code>（即其嵌套级别的方向，如果没有控制符明确限制则为段落基本方向）</li>
</ul>

<p>比如：</p>

<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 段落基本方向是LTR，初始等级0</span>
<span class="err">逻辑顺序：</span><span class="nt">car</span> <span class="nt">means</span> <span class="nt">CAR</span><span class="nc">.</span>
<span class="err">嵌套等级：</span><span class="nt">00000000001110</span>
<span class="err">解释：</span><span class="nt">CAR</span><span class="err">为</span><span class="nt">RTL</span><span class="err">，方向变化所以从</span><span class="nt">0</span><span class="err">提升到</span><span class="nt">1</span><span class="err">；中性字符</span><span class="nc">.</span><span class="err">在段落首尾时遵循</span>

<span class="o">//</span> <span class="err">段落基本方向是</span><span class="nt">RTL</span><span class="err">，初始等级</span><span class="nt">1</span>
<span class="err">逻辑顺序：</span><span class="nt">CAR</span> <span class="nt">means</span> <span class="nt">car</span><span class="nc">.</span>
<span class="err">嵌套等级：</span><span class="nt">11112222222221</span>
<span class="err">解释：第一个空格左右分别时</span><span class="nt">RTL</span><span class="err">和</span><span class="nt">LTR</span><span class="err">，会遵循段落方向；第二个空格左右都是</span><span class="nt">LTR</span><span class="err">，被提升为</span><span class="nt">LTR</span>
</code></pre></div></div>

<p><strong>Q：为什么需要2、3、4等更高等级的嵌套呢？</strong></p>

<ul>
  <li>Unicode中有一些嵌套控制符，可以显示提升嵌套等级，比如LRE（U+202A），RLE（U+202B）等</li>
</ul>

<p><img src="/img/post/文字排版引擎/嵌套控制符.png" alt="嵌套控制符" /></p>

<ul>
  <li>BiDi算法会从最高嵌套等级逐级反转字符，如果没有多级嵌套，遇到复杂结构时（比如 RTL 内嵌 LTR，再内嵌数字），就无法只反转某一层而保持其他层次稳定</li>
</ul>

<p>理解上面概念后，我们来简述BiDi算法的基本过程：</p>

<p><strong>1）分段并确定段落基本方向</strong></p>

<p>BiDi算法是针对段落生效的，拿到一篇文档后，需要先将文档拆分成段落，并为段落确定基本方向。</p>

<p><strong>2）为每个字符分配嵌套等级</strong></p>

<p><strong>3）在奇数层做镜像字符替换</strong></p>

<p>在奇数级别（即 RTL 层级）中，对称字符（如括号、尖括号、引号等）要“镜像”替换。</p>

<p>例如在 RTL 层中，一个 “(” 应该显示为 “)”，一个 “)” 应该显示为 “(”。</p>

<p><strong>4）阿拉伯连字处理</strong></p>

<p>用一个新字符替换相邻的阿拉伯字符，并确定每个阿拉伯字符的位置和形状。</p>

<p><strong>5）按嵌入级别反转子串以生成视觉顺序</strong></p>

<p>对每行（line）分别处理（因为段落可能跨多行），假设最高嵌套等级为<code class="highlighter-rouge">EL_h</code>，<strong>最低奇数级别</strong>为<code class="highlighter-rouge">EL_l</code>，从EL_h递减到EL_l，在每一级别就地反转子串</p>

<p>递归处理完后，由高层级到低层级反转嵌套子串，就能得到最终每行的视觉顺序。</p>

<p>详细逻辑可以参考：https://cs.uwaterloo.ca/~dberry/ATEP/Slides/UnicodeBiDiAlgorithm.pdf</p>

<p>下面以几个例子说明：</p>

<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// case-1</span>
<span class="err">逻辑顺序：</span><span class="na">car</span><span class="err"> </span><span class="na">means</span><span class="err"> </span><span class="na">CAR</span><span class="err">.
段落等级：</span><span class="na">0</span><span class="err">（第一个强字符为</span><span class="na">LTR</span><span class="err">，所以段落等级为</span><span class="na">0</span><span class="err">）
嵌套等级：</span><span class="na">00000000001110</span><span class="err">
反转</span><span class="na">level</span><span class="err"> </span><span class="na">1</span><span class="p">:</span> <span class="n">car</span> <span class="n">means</span> <span class="n">RAC</span><span class="o">.</span>

<span class="o">//</span> <span class="n">case-2</span>
<span class="err">逻辑顺序：</span><span class="p">[</span><span class="n">RLE</span><span class="p">]</span><span class="n">car</span> <span class="n">MEANS</span> <span class="n">CAR</span><span class="o">.</span><span class="p">[</span><span class="n">PDF</span><span class="p">]</span>
<span class="err">段落等级：</span><span class="m">1</span><span class="err">（</span><span class="n">RLT</span><span class="err">开启一个新的嵌套等级，嵌套等级提升到</span><span class="m">1</span><span class="err">，段落等级为</span><span class="m">1</span><span class="err">；</span><span class="n">PDF</span><span class="err">为表示嵌套终止）</span>
<span class="err">嵌套等级：</span>     <span class="m">22211111111111</span>
<span class="err">反转</span><span class="nb">level</span> <span class="m">2</span><span class="err">：</span><span class="n">rac</span> <span class="n">MEANS</span> <span class="n">CAR</span><span class="o">.</span>
<span class="err">反转</span><span class="nb">level</span> <span class="m">1</span><span class="o">~</span><span class="m">2</span><span class="err">：</span><span class="o">.</span><span class="n">RAC</span> <span class="n">SNAEM</span> <span class="n">car</span>

<span class="o">//</span> <span class="n">case-3</span>
<span class="err">逻辑顺序：</span><span class="n">he</span> <span class="n">said</span> <span class="s2">"[RLE]car MEANS CAR[PDF]."</span>
<span class="err">段落等级：</span><span class="m">0</span>
<span class="err">嵌套等级：</span><span class="m">000000000</span>     <span class="m">2221111111111</span>     <span class="m">00</span>
<span class="err">反转</span><span class="nb">level</span> <span class="m">2</span><span class="err">：</span><span class="n">he</span> <span class="n">said</span> <span class="s2">"rac MEANS CAR."</span>
<span class="err">反转</span><span class="nb">level</span> <span class="m">1</span><span class="o">~</span><span class="m">2</span><span class="err">：</span><span class="n">he</span> <span class="n">said</span> <span class="s2">"RAC SNAEM car."</span>
</code></pre></div></div>

<h1 id="四字体匹配与fallback">四、字体匹配与Fallback</h1>

<p>字体匹配与Fallback是一个复杂的过程，我们后续的塑形与测量都依赖字体文件。</p>

<p>由于任何一个字体都不可能覆盖 Unicode 的所有字符，比如：Times New Roman 渲染拉丁字母没问题，但遇到中文 “你” 就会变成“豆腐块”（小方块：是操作系统在没找到合适字体来显示字符时，会兜底到占位符，比如☐或�等）；所以排版系统实际要做的就是：确保每个字符都有合适的字体来渲染，同时尽量保持风格一致。</p>

<p>每个字符都有对应的code point，在<a href="https://mp.weixin.qq.com/s/D0A8HAQaQNart7KAdWXyJg">Font文件中有什么</a>一文中，我们知道了字体文件中有各种各样的表，其中cmap表存储了code point与glyphID的映射，通过cmap表我们可以精确的查到该Font是否支持某个code point，但是仅通过cmap查询是不够的，主要有两个原因：</p>

<ul>
  <li>操作系统一般安装了成百上千种字体，如果对每个code point都去遍历所有Font的cmap表，那开销会非常大</li>
  <li>不同Font支持的Unicode范围是有交集的，一个code point可能匹配出多个Font，为了渲染风格的统一，我们期望相同Script的字符尽量用同一种Font</li>
</ul>

<hr />

<p><strong>Q：相同Script的字符如果使用了不同的Font，会有什么问题</strong></p>

<p>Unicode 为了节省码点空间，将许多中、日、韩来源相同但字形有细微差异的汉字合并到了同一个码点上，也就是所谓的<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E6%97%A5%E9%9F%93%E7%B5%B1%E4%B8%80%E8%A1%A8%E6%84%8F%E6%96%87%E5%AD%97">中日韩统一表意文字</a>（CJK Unified Ideographs）；如下，同一个code point在不同语言下样式不同，如果不处理Script，那可能会在一个日文段落里显示出中文的“房”字形，这在专业排版上是不可接受的。另外，不同的Font格设计风格（字宽、基线、形态）也不同，如果一个段落里穿插不同的Font，那最终排版看起来也会很奇怪。</p>

<p><img src="/img/post/文字排版引擎/CJK Unifined.png" alt="CJK Unifined" /></p>

<p>现代操作系统做字体匹配与Fallback的方式一般是：</p>

<p><strong>1）通过前面的分段，将一段字符串按Script分成不同的run</strong></p>

<p><strong>2）检查用户指定的主字体是否支持</strong></p>

<p>检查用户指定字体（主字体）的cmap是否支持对应字符（code point），如果支持则命中主字体，如果不支持则进入Fallback流程。</p>

<p><strong>3）Fallback时按OS_2表中的ulUnicodeRange掩码初步筛选支持的Unicode范围</strong></p>

<p>注意OS_2表只是一个大概范围，并不代表完全支持该范围的Unicode，如果要精确查询是否支持还是要查cmap表。</p>

<p><strong>4）通过<code class="highlighter-rouge">GSUB</code>/<code class="highlighter-rouge">GPOS</code> 表精确查找支持哪些Script</strong></p>

<p><code class="highlighter-rouge">GSUB</code>/<code class="highlighter-rouge">GPOS</code>中定义了<code class="highlighter-rouge">ScriptList</code>，明确声明字体为哪些Script提供了shaping规则；排版引擎通过<code class="highlighter-rouge">GSUB</code>/<code class="highlighter-rouge">GPOS</code>表来处理复杂的排版规则，比如字形替换、连字、上下标对齐等，排版引擎会优先选择明确支持对应Script的Font。</p>

<p><strong>5）通过cmap表验证支持的code point</strong></p>

<p>如果匹配出多个Fallback字体，那系统可能会根据用户设置的主字体风格，系统语言、字体优先级等来选择最优的字体。</p>

<p>当然，操作系统中一般会对Script的Fallback字体表有缓存，上面的3、4步骤一般不用每次都做，Fallback表类似于：</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="s2">"scripts"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="s2">"hans"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"Microsoft YaHei"</span><span class="p">,</span><span class="w"> </span><span class="s2">"SimSun"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Source Han Sans SC"</span><span class="p">],</span><span class="w">
    </span><span class="s2">"hant"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"Microsoft JhengHei"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Source Han Sans TC"</span><span class="p">],</span><span class="w">
    </span><span class="s2">"latn"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"Arial"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Times New Roman"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Verdana"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Microsoft YaHei"</span><span class="p">,</span><span class="w"> </span><span class="err">...</span><span class="p">],</span><span class="w">
    </span><span class="s2">"kana"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"Meiryo"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Yu Gothic"</span><span class="p">,</span><span class="w"> </span><span class="s2">"Source Han Sans JP"</span><span class="p">]</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="s2">"families"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="s2">"Arial"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="s2">"regular"</span><span class="p">:</span><span class="w"> </span><span class="s2">"arial.ttf"</span><span class="p">,</span><span class="w"> </span><span class="s2">"bold"</span><span class="p">:</span><span class="w"> </span><span class="s2">"arialbd.ttf"</span><span class="w"> </span><span class="p">},</span><span class="w">
    </span><span class="err">...</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>我们后续也会逆向探究下CoreText中的字体级联（Fallback）机制，更细节的这里不再展开。</p>

<hr />

<p><strong>Q：像<code class="highlighter-rouge">👨‍👩‍👧</code>这种由多个code point组成的字符，是怎么匹配Font的</strong></p>

<p>像<code class="highlighter-rouge">👨‍👩‍👧</code>这种由多个code point组成的字符（如下），一般称之为Grapheme Cluster（字素簇）：</p>

<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">👨</span> <span class="o">(</span><span class="nt">U</span><span class="o">+</span><span class="nt">1F468</span><span class="o">,</span> <span class="nt">MAN</span><span class="o">)</span>  
<span class="o">+</span> <span class="nt">U</span><span class="o">+</span><span class="nt">200D</span> <span class="o">(</span><span class="nt">ZWJ</span><span class="o">,</span> <span class="nt">Zero</span> <span class="nt">Width</span> <span class="nt">Joiner</span><span class="o">)</span>  
<span class="o">+</span> <span class="err">👩</span> <span class="o">(</span><span class="nt">U</span><span class="o">+</span><span class="nt">1F469</span><span class="o">,</span> <span class="nt">WOMAN</span><span class="o">)</span>  
<span class="o">+</span> <span class="nt">U</span><span class="o">+</span><span class="nt">200D</span> <span class="o">(</span><span class="nt">ZWJ</span><span class="o">,</span> <span class="nt">Zero</span> <span class="nt">Width</span> <span class="nt">Joiner</span><span class="o">)</span>  
<span class="o">+</span> <span class="err">👧</span> <span class="o">(</span><span class="nt">U</span><span class="o">+</span><span class="nt">1F467</span><span class="o">,</span> <span class="nt">GIRL</span><span class="o">)</span>
</code></pre></div></div>

<p>Unicode Emoji 标准里规定了哪些序列可以组合成单个 emoji（如 👨‍👩‍👧、👩‍❤️‍👩 等），排版引擎会根据Emoji data（来自Unicode数据表）来判断这是不是一个合法的ZWJ Sequence，识别成功会将其视为一个不可分割的单元，在匹配字体时会做如下处理：</p>

<p><strong>1）用组合序列的第一个非ZWJ code point 去查找字体</strong></p>

<blockquote>
  <p>ZWJ：Zero Width Joiner，零宽度连接符，它的作用就像“胶水”，告诉排版引擎两侧字符不可分割。</p>
</blockquote>

<p>对于<code class="highlighter-rouge">👨‍👩‍👧</code>来说，就是用 <code class="highlighter-rouge">U+1F468</code> (👨)，去查找字体，查找和Fallback过程同上。一般而言会匹配到系统内置的彩色表情符号字体：macOS/iOS上一般是<code class="highlighter-rouge">Apple Color Emoji</code>，Windows上是<code class="highlighter-rouge">Segoe UI Emoji</code>，Android上一般是<code class="highlighter-rouge">Noto Color Emoji</code></p>

<p><strong>2）用匹配的字体进行字形替换</strong></p>

<p>这一步其实发生在下面的塑性阶段，在查到的字体表中通过 GSUB表把多个 code point 映射成一个彩色的glyph，也就是字形替换。</p>

<p>如果这一步没找到合法的可替换字形，那就Fallback到单独显示<code class="highlighter-rouge">👨 👩 👧</code></p>

<h1 id="五字形选择与shaping">五、字形选择与Shaping</h1>

<p>这一步的目标是将抽象的字符转换成具体的glyphIDs和布局信息，以供下一步排版使用；输入是一段单一 Script、单一字体的文本 run和上面匹配出的字体，输出是一个字形序列，包括glyphIDs、x_advance、y_advance、x_offset、y_offset等。</p>

<p>大致分为两步：</p>

<p><strong>1）code point映射到glyphID</strong></p>

<p>每个code point会通过字体的cmap表映射成一个glyphID。</p>

<p><strong>2）文本塑形：应用GSUB、GPOS规则</strong></p>

<p>Shaping引擎会读取字体文件中的GSUB表，进行字形替换，比如连字，emoji替换等；读取GPOS表，调整字形的位置，比如上下标位置、字间距（kerning）、阿拉伯文的连写等。</p>

<h1 id="六测量与排版">六、测量与排版</h1>

<p>这一步的目标是将字形序列按自定义布局规则排版到二维坐标系下，简单讲就是确定每个glyph的位置、大小信息，以供下一步绘制使用。</p>

<p>大致分为两步：</p>

<p><strong>1）获取字形的metrics</strong></p>

<p>从字体文件的hhea/OS_2表中读取出每个glyph的ascent、descent等信息，用于确定baseline、lineHeight等信息。</p>

<p><strong>2）自定义布局确定每个glyph位置</strong></p>

<p>从上面得到的baseline、lineHeight等信息，以及第六步得到的advance宽度（glyph前进量）等，可以计算出每个glyph的宽高、对齐基线，这样我们就能像前端一样自定义文档流布局（Inline、Inline-Block、Block）来精确的排版每个glyph的位置。</p>

<h1 id="七渲染上屏">七、渲染上屏</h1>

<p>经过上面的塑形、排版过程，我们已经能得到按显示顺序排列且带有精确位置的glyph序列，绘制阶段就是将这些抽象的glyph序列上屏显示出来。</p>

<p>这一步一般有软光栅、硬光栅等多种选型，在macOS/iOS上，可以通过CoreText来绘制字形序列，比如：<a href="https://developer.apple.com/documentation/coretext/ctfontdrawglyphs(_:_:_:_:_:)">CTFontDrawGlyphs</a>；本文主要讲解排版引擎流程，渲染部分不再展开，后续有时间再单独开篇研究。</p>

<h1 id="总结">总结</h1>

<p>至此，我们自定义文字排版引擎的原理篇告一段落；相信通过以上讲解，我们对文字排版的流程有了一个大致了解，下一步我们将结合ICU、HarfBuzz等来实战实现一个小型的自定义文字排版引擎。</p>

<blockquote>
  <p>更多精彩内容，欢迎关注🌍公众号：非专业程序员Ping</p>
</blockquote>


                <hr>

                


                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2025/09/17/%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82Font%E6%96%87%E4%BB%B6/" data-toggle="tooltip" data-placement="top" title="一文读懂Font文件">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2025/10/03/CoreText-Font-Fallback/" data-toggle="tooltip" data-placement="top" title="CoreText Font Fallback">Next Post &rarr;</a>
                    </li>
                    
                </ul>


                

                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#Algorithm" title="Algorithm" rel="5">
                                    Algorithm
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#Java" title="Java" rel="14">
                                    Java
                                </a>
                            
        				
                            
                				<a href="/tags/#Android" title="Android" rel="10">
                                    Android
                                </a>
                            
        				
                            
                				<a href="/tags/#Hust" title="Hust" rel="2">
                                    Hust
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#操作系统" title="操作系统" rel="3">
                                    操作系统
                                </a>
                            
        				
                            
                				<a href="/tags/#View" title="View" rel="2">
                                    View
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#Note" title="Note" rel="2">
                                    Note
                                </a>
                            
        				
                            
                				<a href="/tags/#iOS" title="iOS" rel="6">
                                    iOS
                                </a>
                            
        				
                            
                				<a href="/tags/#跨端渲染" title="跨端渲染" rel="7">
                                    跨端渲染
                                </a>
                            
        				
                            
                				<a href="/tags/#Font" title="Font" rel="5">
                                    Font
                                </a>
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#逆向" title="逆向" rel="2">
                                    逆向
                                </a>
                            
        				
                            
        				
        			</div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>





<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "HusterYP";
    var disqus_identifier = "/2025/10/01/文字排版引擎";
    var disqus_url = "http://localhost:4000/2025/10/01/%E6%96%87%E5%AD%97%E6%8E%92%E7%89%88%E5%BC%95%E6%93%8E/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                    

                    <!-- add Weibo, Zhihu by Hux, add target = "_blank" to <a> by Hux -->
                    
                    


                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/HusterYP">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 非专业程序员 2025
                    <br>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
